#!/usr/bin/env bash

## TODO:
# - Add support for other distros on Linux
# - Add support for macOS (brew install ...)
# - Add Netflix OCA list check
# - Add Starlink speed test
# - Upload test result to Cloudflare R2 buckets via Worker proxy

VERSION="20260204.5"

help () {
    echo -e "Usage:\n       sudo bash $0 [--install | <interface>]"
    echo -e "\nArguments:"
    echo "  --install       Install required packages and tools"
    echo "  <interface>     Specify the Starlink interface to use for measurements"
    echo -e "\nExamples:"
    echo -e "  # One-liner Execution"
    echo "  curl -fsSL https://starlink.jinwei.me | sudo bash -s -- --install"
    echo "  curl -fsSL https://starlink.jinwei.me | sudo bash -s -- eth0"
    echo -e "\n  # Local Execution"
    echo "  wget -O starlink.sh https://starlink.jinwei.me"
    echo "  sudo bash starlink.sh --install"
    echo "  sudo bash starlink.sh eth0"
    echo -e "\nNote:\n  Rich image rendering in terminal requires a modern terminal emulator. (e.g., iTerm2, Ghostty, WezTerm, Kitty, etc.)"
    echo -e "\nContact: clarkzjw@uvic.ca"
    echo -e "Version: $VERSION"
    exit 1
}

STARLINK_GRPC_ENDPOINT="192.168.100.1:9200"
STARLINK_GW="100.64.0.1"

#######################################################
# Detect terminal emulator type and its image protocol support
# Some of the code in this section is generated by AI coding tools
#######################################################

# --- 1. Helper Function: Send Query and Read Raw Response ---
function query_terminal() {
    local query="$1"

    # Check if /dev/tty is available (it won't be in non-interactive environments)
    if [ ! -t 0 ] && [ ! -e /dev/tty ]; then
        return
    fi

    # Save settings and set raw mode using /dev/tty specifically
    local old_stty=$(stty -g -F /dev/tty 2>/dev/null || stty -g < /dev/tty)
    stty -F /dev/tty raw -echo min 0 time 5 2>/dev/null || stty raw -echo min 0 time 5 < /dev/tty

    # Send the query to the terminal
    printf "$query" > /dev/tty

    local response=""
    # Open /dev/tty for reading specifically on file descriptor 3
    exec 3< /dev/tty
    while IFS= read -r -n1 -t 0.1 char <&3; do
        response+="$char"
        if [[ "$response" == *$'\007' ]] || [[ "$response" == *$'\033\\' ]]; then
            break
        fi
    done
    exec 3<&- # Close FD 3

    # Restore terminal settings
    stty -F /dev/tty "$old_stty" 2>/dev/null || stty "$old_stty" < /dev/tty

    echo "$response"
}

# --- Step A: Try XTVERSION (Identifies WezTerm, iTerm2, Ghostty, Kitty) ---
# Sequence: ESC [ > q
xt_response=$(query_terminal '\033[>q')

# Variables to store results
TERM_NAME="Unknown"
PROTOCOLS=""

if [[ "$xt_response" == *"iTerm2"* ]]; then
    TERM_NAME="iTerm2"
    PROTOCOLS="iterm"
elif [[ "$xt_response" == *"WezTerm"* ]]; then
    TERM_NAME="WezTerm"
    PROTOCOLS="iterm"
elif [[ "$xt_response" == *"ghostty"* ]]; then
    TERM_NAME="Ghostty"
    PROTOCOLS="kitty"
elif [[ "$xt_response" == *"kitty"* ]]; then
    TERM_NAME="Kitty"
    PROTOCOLS="kitty"
else
    # --- Step B: Fallback for macOS Terminal / Generic Sixel ---
    # If XTVERSION failed, it might be macOS Terminal or a generic Sixel terminal (like mlterm)

    # Check for Sixel specifically using DA1 (ESC [ c)
    da1_response=$(query_terminal '\033[c')

    # Check for ';4' or '?4' which indicates Sixel support
    if [[ "$da1_response" == *";4"* ]] || [[ "$da1_response" == *"?4"* ]]; then
        TERM_NAME="Generic Sixel Terminal"
        PROTOCOLS="sixel"
    else
        # If no Identity and no Sixel, it is likely standard macOS Terminal
        # macOS Terminal (Terminal.app) is notably "dumb" regarding these queries
        TERM_NAME="macOS Terminal (or Standard XTerm)"
        PROTOCOLS="none"
    fi
fi

#######################################################

test () {
    command -v "$1" >/dev/null 2>&1
    return $?
}

test_ipv6 () {
    curl -6 -s --connect-timeout 5 https://one.one.one.one >/dev/null
    return $?
}

get_uuid () {
    uuid=$(python3 -c "import uuid; print(str(uuid.uuid5(uuid.NAMESPACE_DNS, str(uuid.getnode()))))")
    echo "$uuid"
}

get_datetime () {
    datetime=$(date -u "+%Y%m%d-%H%M%S")
    echo "$datetime"
}

DATA_DIR=""
datetime=$(get_datetime)

INIT_FLAG=False
IFACE=""
if [ "$1" == "--install" ]; then
  INIT_FLAG=True
elif [ -n "$1" ]; then
    IFACE="$1"
    if ! ip link show "$IFACE" >/dev/null 2>&1; then
        echo "Interface $IFACE does not exist."
        exit 1
    fi
fi

USER_ID=$(id -u)
if [ "$USER_ID" -ne 0 ]; then
  echo "This script must be run as root. Please use sudo."
  help
fi

install () {
    OS="$(uname -s)"
    echo "Detected OS: $OS"
    if [ "$OS" != "Linux" ]; then
        echo "This script only supports Linux."
        exit 1
    fi

    DISTRO="$(. /etc/os-release && echo "$ID")"
    echo "Detected distribution: $DISTRO"

    if [ "$DISTRO" != "ubuntu" ] && [ "$DISTRO" != "debian" ]; then
        echo "This script only supports Ubuntu and Debian."
        exit 1
    fi

    ARCH="$(dpkg --print-architecture)"
    echo "Detected architecture: $ARCH"

    echo "Updating package lists..."
    apt-get update

    echo "Installing essential packages..."
    apt-get install -y curl gnupg2 ca-certificates lsb-release traceroute mtr iputils-ping screen jq bind9-dnsutils wget python3 jq

    echo "Install additional tools..."
    apt-get install -y chafa gnuplot gawk

    echo "Importing GPG key..."
    curl -fsSL https://pkg.jinwei.me/clarkzjw-pkg.key | tee /etc/apt/keyrings/clarkzjw-pkg.asc

    echo "Adding Lens repository..."
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/clarkzjw-pkg.asc] https://pkg.jinwei.me/lens any main" | tee /etc/apt/sources.list.d/starlink-lens.list

    echo "Adding Starlink-Telegraf repository..."
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/clarkzjw-pkg.asc] https://pkg.jinwei.me/starlink-telegraf any main" | tee /etc/apt/sources.list.d/starlink-telegraf.list

    apt-get update && apt-get install lens starlink-telegraf -y

    GRPCURL_VERSION=$(curl -s "https://api.github.com/repos/fullstorydev/grpcurl/tags" | jq -r '.[0].name')
    GRPCURL_VERSION="${GRPCURL_VERSION#v}"
    echo "Latest grpcurl version: $GRPCURL_VERSION"
    GRPCURL_PKG_URL=https://github.com/fullstorydev/grpcurl/releases/download/v"$GRPCURL_VERSION"/grpcurl_"$GRPCURL_VERSION"_linux_"$ARCH".deb
    echo "Downloading grpcurl from $GRPCURL_PKG_URL..."
    wget --quiet -O /tmp/grpcurl.deb "$GRPCURL_PKG_URL"
    dpkg -i /tmp/grpcurl.deb && rm -f /tmp/grpcurl.deb
    grpcurl --version

    echo "Installing speedtest-cli..."
    curl -s https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.deb.sh | bash
    apt-get install speedtest -y
}

test_subnet () {
    IP="$1"
    CIDR_FILE="$2"

    cidr=$(python3 -c "import ipaddress, sys; ip = ipaddress.ip_address('$IP'); matches = [l.strip() for l in open('$CIDR_FILE') if l.strip() and ip in ipaddress.ip_network(l.strip(), strict=False)]; print(*matches, sep='\n') if matches else sys.exit(1)")

    if [ $? -eq 0 ]; then
        echo -e "\nMatch $cidr" >> "$DATA_DIR/geoip.txt"
        grep "$cidr" feed.csv >> "$DATA_DIR/geoip.txt"  || echo -e "\nNo matching subnet $cidr in feed.csv" >> "$DATA_DIR/geoip.txt"
        grep "$cidr" pops.csv >> "$DATA_DIR/geoip.txt" || echo -e "\nNo matching subnet $cidr in pops.csv" >> "$DATA_DIR/geoip.txt"
    else
        echo -e "\nNo Match"
    fi
}

geoip () {
    echo -e "\n###### Downloading feed.csv and pops.csv from geoip.starlinkisp.net..."

    wget --quiet -O feed.csv https://geoip.starlinkisp.net/feed.csv
    wget --quiet -O pops.csv https://geoip.starlinkisp.net/pops.csv

    cat feed.csv | awk -F',' '{print $1}' > subnet.txt

    echo -e "\n\n###### Checking GeoIP and PoP information"
    curl -4 -s ipinfo.io --interface "$IFACE" > "$DATA_DIR/geoip.txt"
    v4_ip=$(curl -4 -s ipinfo.io/ip --interface "$IFACE")

    if [ "$IPV6_AVAILABLE" -eq 0 ]; then
        curl -6 -s v6.ipinfo.io --interface "$IFACE" >> "$DATA_DIR/geoip.txt"
        v6_ip=$(curl -6 -s v6.ipinfo.io/ip --interface "$IFACE")
    fi

    test_subnet "$v4_ip" "subnet.txt" >> "$DATA_DIR/geoip.txt"
    if [ "$IPV6_AVAILABLE" -eq 0 ]; then
        test_subnet "$v6_ip" "subnet.txt" >> "$DATA_DIR/geoip.txt"
    fi

    cat "$DATA_DIR/geoip.txt"
    mv pops.csv "$DATA_DIR/pops.csv"
    mv feed.csv "$DATA_DIR/feed.csv"
    rm -f subnet.txt
}

cf_ray () {
    echo -e "\n###### Cloudflare Ray ID"
    curl -sI https://www.cloudflare.com/cdn-cgi/trace | grep cf-ray > "$DATA_DIR/cf-ray.txt"
    cat "$DATA_DIR/cf-ray.txt"
}

dns () {
    # TODO: support -b option to bind to specific interface
    echo -e "\n###### Checking DNS resolver locations"
    OPTIONS="CHAOS TXT id.server +nsid"
    echo -e "-- Cloudflare DNS" > "$DATA_DIR/dig.txt"
    dig @1.1.1.1 $OPTIONS >> "$DATA_DIR/dig.txt"
    echo -e "-- Google DNS" >> "$DATA_DIR/dig.txt"
    dig @8.8.8.8 $OPTIONS >> "$DATA_DIR/dig.txt"
    echo -e "-- Quad9 DNS" >> "$DATA_DIR/dig.txt"
    dig @9.9.9.9 $OPTIONS >> "$DATA_DIR/dig.txt"

    cat "$DATA_DIR/dig.txt"
}

traceroute_trace () {
    echo -e "###### Traceroute to Cloudflare"

    OPTIONS="-I -e"
    if [ -n "$IFACE" ]; then
        OPTIONS="$OPTIONS -i $IFACE"
    fi
    traceroute 1.1.1.1 $OPTIONS > "$DATA_DIR/traceroute.txt"
    if [ "$IPV6_AVAILABLE" -eq 0 ]; then
        traceroute 2606:4700:4700::1111 $OPTIONS >> "$DATA_DIR/traceroute.txt"
    fi

    cat "$DATA_DIR/traceroute.txt"
}

mtr_trace () {
    echo -e "\n###### MTR to Cloudflare"

    OPTIONS="-r -w -i 1 -c 10 -b -G 1"
    if [ -n "$IFACE" ]; then
        OPTIONS="$OPTIONS -I $IFACE"
    fi
    mtr 1.1.1.1 $OPTIONS > "$DATA_DIR/mtr.txt"
    if [ "$IPV6_AVAILABLE" -eq 0 ]; then
        mtr 2606:4700:4700::1111 $OPTIONS >> "$DATA_DIR/mtr.txt"
    fi

    cat "$DATA_DIR/mtr.txt"
}

grpc_status () {
    echo -e "\n###### Starlink GRPC Status"
    grpcurl -plaintext -d {\"get_status\":{}} $STARLINK_GRPC_ENDPOINT SpaceX.API.Device.Device/Handle > "$DATA_DIR/grpc_status.json"
    cat "$DATA_DIR/grpc_status.json" | jq '.'

    echo -e "\n###### Starlink GRPC Location"
    grpcurl -plaintext -d {\"get_location\":{}} $STARLINK_GRPC_ENDPOINT SpaceX.API.Device.Device/Handle > "$DATA_DIR/grpc_location.json"
    cat "$DATA_DIR/grpc_location.json" | jq '.'
}

show_networking () {
    echo -e "###### Networking Interfaces"
    ip addr show
    echo -e "\n###### Routing Table"
    ip route show
}

obstruction_map () {
    echo -e "\n###### Generating Obstruction Map"
    lens -map
    ls -alh obstruction-map-*.png
    filename=$(ls -alh obstruction-map-* -t | head -n 1 | awk '{print $9}')
    mv "$filename" "$DATA_DIR/$filename"
    echo "Obstruction map image saved to $DATA_DIR/$filename"
    if test chafa; then
        chafa "$DATA_DIR/$filename" -f $PROTOCOLS -s 25x25
    fi
}

ping_gw () {
    echo -e "\n###### Ping Starlink Gateway"

    ping -D -I "$IFACE" -c 10000 -i 0.01 "$STARLINK_GW" > ping-$STARLINK_GW-$datetime.txt
    ls -alh ping-$STARLINK_GW-*.txt

    filename=$(ls -alh ping-$STARLINK_GW-*.txt -t | head -n 1 | awk '{print $9}')
    echo "Ping $STARLINK_GW result saved to $filename"

    if test gawk && test gnuplot; then
        echo "Generating ping latency plot..."
        gawk 'BEGIN {prev_id=-1; nroll=0} $3=="bytes" {id=substr($6,10); if (prev_id-id>10000){nroll+=1}; seqid=65536*nroll+id; prev_id=id; print seqid,substr($8,6)}' "$filename" | gnuplot -e "set terminal png size 3000,500; set output '$filename.png'; unset label; unset key; plot '-'"
        mv "$filename.png" "$DATA_DIR/$filename.png"
        mv "$filename" "$DATA_DIR/$filename"

        chafa "$DATA_DIR/$filename.png" -f $PROTOCOLS
    else
        echo "gawk or gnuplot not found, skipping latency plot generation."
        return
    fi
}

setup_directory () {
    DATA_DIR="data/$datetime"
    mkdir -p "$DATA_DIR"
}

cleanup () {
    tar -czvf "data/$datetime.tar.gz" "$DATA_DIR"
    rm -rf "$DATA_DIR"
    echo "All data saved to data/$datetime.tar.gz"
}

run_once() {
    if [ -z "$IFACE" ]; then
        echo -e "Error: No interface name specified. \n       Please provide the interface name that is connected to Starlink."
        echo -e "\nAvailable interfaces: \n       $(ls /sys/class/net | grep -Ev "lo|br|docker0|veth|tailscale0" | xargs)\n"
        help
    fi

    IPV6_AVAILABLE=$(test_ipv6; echo $?)

    show_networking
    grpc_status
    geoip
    cf_ray
    dns
    traceroute_trace
    mtr_trace
    obstruction_map
    ping_gw
}

if [ "$INIT_FLAG" == "True" ]; then
    install
    exit 0
fi

setup_directory
run_once
cleanup
